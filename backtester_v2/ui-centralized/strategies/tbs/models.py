"""
TBS (Time-Based Strategy) Data Models
Supports time-based trading strategies with precise timing controls
"""

from dataclasses import dataclass, field
from typing import List, Optional, Dict, Any, Union
from datetime import date, time, datetime
from enum import Enum
from pydantic import BaseModel, Field, validator
import pandas as pd


class TimeZone(str, Enum):
    """Supported time zones for TBS strategy"""
    IST = "Asia/Kolkata"
    UTC = "UTC"
    EST = "America/New_York"
    PST = "America/Los_Angeles"


class TradingSession(str, Enum):
    """Trading session types"""
    PRE_MARKET = "PRE_MARKET"
    REGULAR = "REGULAR"
    POST_MARKET = "POST_MARKET"
    EXTENDED = "EXTENDED"


class TimeCondition(str, Enum):
    """Time-based conditions for strategy execution"""
    EXACT_TIME = "EXACT_TIME"
    TIME_RANGE = "TIME_RANGE"
    BEFORE_TIME = "BEFORE_TIME"
    AFTER_TIME = "AFTER_TIME"
    MARKET_OPEN = "MARKET_OPEN"
    MARKET_CLOSE = "MARKET_CLOSE"


class PositionType(str, Enum):
    """Position types for options"""
    BUY = "BUY"
    SELL = "SELL"


class OptionType(str, Enum):
    """Option types"""
    CALL = "CE"
    PUT = "PE"


class OrderType(str, Enum):
    """Order types for execution"""
    MARKET = "MARKET"
    LIMIT = "LIMIT"
    STOP_LOSS = "STOP_LOSS"
    STOP_LIMIT = "STOP_LIMIT"


@dataclass
class TimeBasedConfig:
    """Configuration for time-based strategy parameters"""
    start_time: time
    end_time: time
    time_zone: TimeZone = TimeZone.IST
    trading_session: TradingSession = TradingSession.REGULAR
    time_condition: TimeCondition = TimeCondition.EXACT_TIME
    buffer_minutes: int = 0
    
    def __post_init__(self):
        """Validate time configuration"""
        if self.start_time >= self.end_time:
            raise ValueError("Start time must be before end time")


@dataclass
class TBSPosition:
    """Individual position in TBS strategy"""
    symbol: str
    option_type: OptionType
    strike_price: float
    expiry_date: date
    position_type: PositionType
    quantity: int
    entry_time: Optional[time] = None
    exit_time: Optional[time] = None
    entry_price: Optional[float] = None
    exit_price: Optional[float] = None
    order_type: OrderType = OrderType.MARKET
    
    def __post_init__(self):
        """Validate position parameters"""
        if self.quantity <= 0:
            raise ValueError("Quantity must be positive")
        if self.strike_price <= 0:
            raise ValueError("Strike price must be positive")


@dataclass
class TBSSignal:
    """Trading signal generated by TBS strategy"""
    signal_id: str
    timestamp: datetime
    symbol: str
    action: str  # BUY, SELL, HOLD
    quantity: int
    price: Optional[float] = None
    confidence: float = 1.0
    time_trigger: time = None
    conditions_met: List[str] = field(default_factory=list)
    risk_metrics: Dict[str, float] = field(default_factory=dict)
    
    def __post_init__(self):
        """Validate signal parameters"""
        if not 0 <= self.confidence <= 1:
            raise ValueError("Confidence must be between 0 and 1")
        if self.quantity <= 0:
            raise ValueError("Quantity must be positive")


class TBSConfigModel(BaseModel):
    """Pydantic model for TBS strategy configuration"""
    
    # Time-based parameters
    start_time: time = Field(..., description="Strategy start time")
    end_time: time = Field(..., description="Strategy end time")
    time_zone: TimeZone = Field(TimeZone.IST, description="Time zone for strategy")
    trading_session: TradingSession = Field(TradingSession.REGULAR, description="Trading session")
    
    # Position parameters
    max_positions: int = Field(5, ge=1, le=20, description="Maximum number of positions")
    position_size: int = Field(50, ge=1, description="Default position size")
    max_trades_per_day: int = Field(10, ge=1, description="Maximum trades per day")
    
    # Risk management
    max_loss_per_trade: float = Field(1000.0, ge=0, description="Maximum loss per trade")
    max_daily_loss: float = Field(5000.0, ge=0, description="Maximum daily loss")
    profit_target: Optional[float] = Field(None, ge=0, description="Profit target per trade")
    
    # Timing parameters
    entry_buffer_minutes: int = Field(0, ge=0, le=60, description="Entry time buffer")
    exit_buffer_minutes: int = Field(0, ge=0, le=60, description="Exit time buffer")
    
    # Strategy-specific parameters
    time_conditions: List[TimeCondition] = Field(default_factory=list, description="Time-based conditions")
    symbols: List[str] = Field(default_factory=list, description="Trading symbols")
    
    @validator('end_time')
    def validate_time_order(cls, v, values):
        """Validate that end time is after start time"""
        if 'start_time' in values and v <= values['start_time']:
            raise ValueError('End time must be after start time')
        return v
    
    @validator('symbols')
    def validate_symbols(cls, v):
        """Validate trading symbols"""
        if not v:
            raise ValueError('At least one symbol must be specified')
        return v


@dataclass
class TBSExecutionResult:
    """Result of TBS strategy execution"""
    strategy_name: str = "TBS"
    execution_timestamp: datetime = field(default_factory=datetime.now)
    signals_generated: List[TBSSignal] = field(default_factory=list)
    positions_opened: List[TBSPosition] = field(default_factory=list)
    positions_closed: List[TBSPosition] = field(default_factory=list)
    total_pnl: float = 0.0
    execution_time_ms: float = 0.0
    success: bool = True
    error_message: Optional[str] = None
    
    def add_signal(self, signal: TBSSignal):
        """Add a trading signal to the result"""
        self.signals_generated.append(signal)
    
    def add_position(self, position: TBSPosition, action: str):
        """Add a position to the appropriate list"""
        if action.upper() == "OPEN":
            self.positions_opened.append(position)
        elif action.upper() == "CLOSE":
            self.positions_closed.append(position)
    
    def calculate_pnl(self):
        """Calculate total P&L from closed positions"""
        total_pnl = 0.0
        for position in self.positions_closed:
            if position.entry_price and position.exit_price:
                if position.position_type == PositionType.BUY:
                    pnl = (position.exit_price - position.entry_price) * position.quantity
                else:  # SELL
                    pnl = (position.entry_price - position.exit_price) * position.quantity
                total_pnl += pnl
        
        self.total_pnl = total_pnl
        return total_pnl


@dataclass
class TBSMarketData:
    """Market data structure for TBS strategy"""
    symbol: str
    timestamp: datetime
    open_price: float
    high_price: float
    low_price: float
    close_price: float
    volume: int
    option_chain: Optional[Dict[str, Any]] = None
    
    def __post_init__(self):
        """Validate market data"""
        prices = [self.open_price, self.high_price, self.low_price, self.close_price]
        if any(price <= 0 for price in prices):
            raise ValueError("All prices must be positive")
        if self.volume < 0:
            raise ValueError("Volume cannot be negative")


@dataclass
class TBSRiskMetrics:
    """Risk metrics for TBS strategy"""
    max_drawdown: float = 0.0
    current_drawdown: float = 0.0
    var_95: float = 0.0  # Value at Risk 95%
    expected_shortfall: float = 0.0
    sharpe_ratio: float = 0.0
    win_rate: float = 0.0
    profit_factor: float = 0.0
    max_consecutive_losses: int = 0
    
    def update_metrics(self, returns: List[float]):
        """Update risk metrics based on returns"""
        if not returns:
            return
        
        # Calculate basic metrics
        positive_returns = [r for r in returns if r > 0]
        negative_returns = [r for r in returns if r < 0]
        
        self.win_rate = len(positive_returns) / len(returns) if returns else 0
        
        if positive_returns and negative_returns:
            gross_profit = sum(positive_returns)
            gross_loss = abs(sum(negative_returns))
            self.profit_factor = gross_profit / gross_loss if gross_loss > 0 else float('inf')
        
        # Calculate drawdown
        cumulative_returns = pd.Series(returns).cumsum()
        running_max = cumulative_returns.expanding().max()
        drawdown = cumulative_returns - running_max
        self.max_drawdown = abs(drawdown.min()) if not drawdown.empty else 0
        self.current_drawdown = abs(drawdown.iloc[-1]) if not drawdown.empty else 0


# Type aliases for convenience
TBSConfig = Union[TBSConfigModel, Dict[str, Any]]
TBSData = Union[TBSMarketData, pd.DataFrame]
TBSResult = TBSExecutionResult
